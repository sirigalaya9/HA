// This class allows advanced customizations for the mapping of records from DS_SAP_Customer_SalesData_KNVV__c to Account.
// This class is constructed and executed each batch. Your class fields and properties will loose their values after each batch is complete.
// To retain data for the lifetime of the whole batch process, set the property persistentState.
// 
// Scenario: DS_SAP_Customer_SalesData
// Source Object: DS_SAP_Customer_SalesData_KNVV__c
// Target Object: Account
// Mapping Record Name: OM_KNVV_to_Account
// Direction: Inbound
// 
// Generated by Overcast 2024-02-29 03:57:04Z
// Your changes will not be overwritten when resaving the mapping.
//
global class Mapping_OM_KNVV_to_Account extends overcast.ObjectMapping.PluginExtension implements overcast.ObjectMapping.EventPlugin, overcast.ObjectMapping.BatchableEventPlugin {
	static final String customerCreditDataScenario = 'DS_SAP_Customer_CreditData';
    static final String customerAccOwnerScenario = 'DS_SAP_Customer_AccOwner';

    // Base class properties (Do not uncomment these properties.)
    //
    // Set perisistentState with your own object/data to retain any state for the duration of the batch job.
    // global Object persistentState
    global void execute(overcast__Run__c scenarioExecution, DS_SAP_Customer_SalesData_KNVV__c[] records) {
        m_logger = new overcast.Logger(scenarioExecution.Id);

        overcast.ObjectMapping.MappingConfig config = new overcast.ObjectMapping.MappingConfig('DS_SAP_Customer_SalesData_KNVV__c', records);
        config.rollbackOnError = false;
        // config.dmlOptions = new Database.DmlOptions(); // If set, config.dmlOptions will be used for the DML operations.
        // config.batchSize = 200; // Also set in UI. Allows dynamic setting of batch size.
        config.eventplugin = this;
        config.mappings = [SELECT overcast__Name__c, overcast__Target__c, overcast__Map__c, overcast__Joins__c, overcast__BatchSize__c
                    FROM overcast__IntegrationFieldMap__c 
                    WHERE overcast__ApexClass__c = 'Mapping_OM_KNVV_to_Account'];
        config.logger = m_logger;
        config.scenarioExecution = scenarioExecution;
        
        // Perform your pre-mapping processing here. Perform mid-mapping processing in beforeUpsert().
        
        // Start of Custom Code | 2024-03-04 00:00:00Z
    	Set<String> customerNumberSet = new Set<String>();
		for (DS_SAP_Customer_SalesData_KNVV__c customerRecords : records) {
			customerNumberSet.add(customerRecords.KUNNR__c);
		}
        // End of Custom Code | 2024-03-04 00:00:00Z
        
        // Run main mapping process.
        overcast.ObjectMapping.run(config);
        
        // Perform your post-mapping processing here.
        
        // Start of Custom Code | 2024-03-04 00:00:00Z
        boolean runCustomerCreditDataScenario = true;
        overcast.Run dataSync1;
        
        boolean runCustomerAccOwnerScenario = true;
        overcast.Run dataSync2;
        
        if (customerNumberSet.isEmpty()) {
            runCustomerCreditDataScenario = false;
            runCustomerAccOwnerScenario = false;
		} else {
			// Create a query predicate for customer IDs.
			overcast.Predicate p1 = new overcast.Predicate(null, overcast.Predicate.FilterType.AND1, '');
			p1.add(new overcast.Predicate('KUNNR__c', overcast.Predicate.FilterType.IN1, new List<String>(customerNumberSet)));

            // Create a query predicate for customer numbers and partner function.
            overcast.Predicate p2 = new overcast.Predicate(null, overcast.Predicate.FilterType.AND1, '');
            p2.add(new overcast.Predicate('KUNNR__c', overcast.Predicate.FilterType.IN1, new List<String>(customerNumberSet)));
            p2.add(new overcast.Predicate('PARVW__c', overcast.Predicate.FilterType.IN1, 'ZE'));

			// Create an execution instance of the Customer Credit Data Scenario
            overcast__ScenarioTables__c[] st1 = [SELECT Id, overcast__Scenario__c FROM overcast__ScenarioTables__c WHERE overcast__Scenario__r.Name = :customerCreditDataScenario LIMIT 1];
            
            if (st1.isEmpty()){
				runCustomerCreditDataScenario = false;
				logError('Unable to find scenario information for ' + customerCreditDataScenario);
				setStatusToError();
			} else {
				overcast__InputSet__c input1 = new overcast__InputSet__c(Name = 'auto_' + overcast.Utilities.NewGuid(), overcast__Scenario__c = st1[0].overcast__Scenario__c, overcast__ScenarioTables__c = st1[0].Id);
				input1.overcast__Condition2__c = p1.serialize();
				insert input1;
			
				dataSync1 = new overcast.Run(customerCreditDataScenario, input1.Name);
			}
            
            // Create an execution instance of the Customer Account Owner Scenario
            overcast__ScenarioTables__c[] st2 = [SELECT Id, overcast__Scenario__c FROM overcast__ScenarioTables__c WHERE overcast__Scenario__r.Name = :customerAccOwnerScenario LIMIT 1];
            
            if (st2.isEmpty()){
				runCustomerAccOwnerScenario = false;
				logError('Unable to find scenario information for ' + customerAccOwnerScenario);
				setStatusToError();
			} else {
				overcast__InputSet__c input2 = new overcast__InputSet__c(Name = 'auto_' + overcast.Utilities.NewGuid(), overcast__Scenario__c = st2[0].overcast__Scenario__c, overcast__ScenarioTables__c = st2[0].Id);
				input2.overcast__Condition2__c = p2.serialize();
				insert input2;
			
				dataSync2 = new overcast.Run(customerAccOwnerScenario, input2.Name);
			}
		}
        
		// Put the data sync executions into the queue.
		Boolean allOrNothing = false;
		Set<overcast.Run> dataSynList = new Set<overcast.Run>();
        
        if (runCustomerCreditDataScenario) {
            dataSynList.add(dataSync1);
        }
        
        if (runCustomerAccOwnerScenario) {
            dataSynList.add(dataSync2);
        }
        
		overcast.Scenario.runAsync(new List<overcast.Run>(dataSynList), m_logger, allOrNothing);
        // End of Custom Code | 2024-03-04 00:00:00Z

        // Finish processing for batch.
        this.saveLogs();
    }

    // BeforeUpsert is called for each record that will be inserted/updated into the target object.
    // If the target record has an ID it will be updated, otherwise inserted.
    // Return true to accept the record for insert/update. False to reject the record.
    global boolean beforeUpsert(sobject sourceRecord, sobject targetRecord) {
        DS_SAP_Customer_SalesData_KNVV__c source = (DS_SAP_Customer_SalesData_KNVV__c)sourceRecord;
        //Account target = (Account)targetRecord;
        return source.ovcMapThisRecord__c;
    }
    
    // AfterInsert is called after both insert and update DML operations are successful. 
    // If rollbackOnError is true and a DML exception occurs when inserting or updating, the transaction is rolled back and AfterInsert is not called.
    // If rollbackOnError is false and a DML exception occurs when inserting or updating, AfterInsert is called and saveResults will contain the error messages.
    global void afterInsert(sobject[] insertedRecords, Database.SaveResult[] saveResults) { 
        integer failedCount = 0;
        for (integer i = 0; i < saveResults.size(); ++i) {
            Database.Saveresult saveResult = saveResults[i];
            
            if (!saveResult.isSuccess()) {
                sobject insertedRecord = insertedRecords[i];
                list<string> fieldErrors = new list<string>(); 
                for (string fieldName : saveResult.getErrors()[0].getFields()) {
                    fieldErrors.add(fieldName + '=' + string.valueof(insertedRecord.get(fieldName)));
                }
                
                LogError(string.format('Failed to save record [ID={0}, Message={1}:{2}, {3}]', 
                    new string[]{
                        insertedRecord.Id, 
                        string.valueof(saveResult.getErrors()[0].getStatusCode()), 
                        saveResult.getErrors()[0].getMessage(), 
                        string.join(fieldErrors, ', ')
                    }));
                
                ++failedCount;
            }
        }
        if (failedCount > 0) {
            logError(string.format('{0} of {1} records failed to save.', 
                new string[]{ 
                    string.valueof(failedCount), 
                    string.valueof(insertedRecords.size()) 
                }));
            setStatusToError();
        }
    }
    
    // AfterUpdate Is called after both insert And update DML operations are successful. 
    // If rollbackOnError is true and a DML exception occurs when inserting or updating, the transaction is rolled back and AfterUpdate is not called.
    // If rollbackOnError is false and a DML exception occurs when inserting or updating, AfterUpdate is called and saveResults will contain the error messages.
    global void afterUpdate(sobject[] updatedRecords, Database.SaveResult[] saveResults) {  
        afterInsert(updatedRecords, saveResults);
    }
  
    // Begin helper methods.
        
    // Log an error message to the scenario execution log.
    global void logError(String message) {
        m_logger.addLog('ERROR', '[Mapping_OM_KNVV_to_Account] ' + message);
    }
    
    // Log an warning message to the scenario execution log.
    global void logWarning(String message) {
        m_logger.addLog('WARN', '[Mapping_OM_KNVV_to_Account] ' + message);
    }
    
    // Log an info message to the scenario execution log.
    global void logInfo(String message) {
        m_logger.addLog('INFO', '[Mapping_OM_KNVV_to_Account] ' + message);
    }

    // Log a debug message to the scenario execution log.
    global void logDebug(String message) {
        m_logger.addLog('DEBUG', '[Mapping_OM_KNVV_to_Account] ' + message);
    }
    
    // Set the scenario execution status to error.
    global void setStatusToError() {
        m_logger.setStatusCode(400);
    }
    
    // Set the scenario execution status to warning.
    global void setStatusToWarning() {
        m_logger.setStatusCode(500);
    }
    
    global void saveLogs() {
        m_logger.commitToDatabase();
    }
    
    // End helper methods.

    @testvisible
    private overcast.Logger m_logger;

    global override overcast.Logger getLogger() {
        return m_logger;
    }  
}